<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Babbler Control</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/svg+xml" href="/assets/megaphone.svg" />
    <style>
        :root {
            --bg: #081624;
            --panel: #11253b;
            --panel-soft: #193754;
            --ink: #eef4fb;
            --muted: #9fb5cc;
            --accent: #ff7b29;
            --danger: #db3c4c;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            color: var(--ink);
            background:
                radial-gradient(circle at 20% 10%, #1b476b, transparent 35%),
                radial-gradient(circle at 85% 90%, #572430, transparent 30%),
                var(--bg);
            padding: 2rem;
        }

        .wrap {
            max-width: 980px;
            margin: 0 auto;
            display: grid;
            gap: 1rem;
        }

        .panel {
            background: rgba(17, 37, 59, 0.9);
            border: 1px solid rgba(238, 244, 251, 0.12);
            border-radius: 16px;
            padding: 1.2rem;
            backdrop-filter: blur(4px);
        }

        h1 {
            margin: 0 0 0.5rem 0;
            letter-spacing: 0.03em;
        }

        .title-row {
            display: flex;
            align-items: center;
            gap: 0.65rem;
        }

        .title-icon {
            width: 34px;
            height: 34px;
            flex: 0 0 auto;
        }

        .muted {
            color: var(--muted);
        }

        .access-box {
            margin-top: 0.9rem;
            border: 1px solid rgba(238, 244, 251, 0.14);
            border-radius: 12px;
            padding: 0.85rem;
            background: rgba(10, 22, 36, 0.55);
        }

        .access-row {
            display: flex;
            gap: 0.65rem;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 0.4rem;
        }

        .access-value {
            font-family: Consolas, monospace;
            font-size: 0.95rem;
            color: #d6e5f5;
            word-break: break-all;
        }

        .access-pin {
            font-family: Consolas, monospace;
            font-size: 1.15rem;
            letter-spacing: 0.08em;
            color: #ffd2a7;
            font-weight: 700;
        }

        .small-btn {
            width: auto;
            padding: 0.45rem 0.65rem;
            font-size: 0.8rem;
        }

        .icon-btn {
            width: auto;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.38rem;
            border-radius: 8px;
        }

        .icon-btn svg {
            width: 15px;
            height: 15px;
            fill: currentColor;
        }

        .grid {
            display: grid;
            gap: 0.8rem;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            margin-top: 1rem;
        }

        .inline-row {
            display: flex;
            gap: 0.45rem;
            align-items: stretch;
        }

        .inline-row select {
            flex: 1;
        }

        .inline-row .small-btn {
            flex: 0 0 auto;
            margin: 0;
            align-self: stretch;
        }

        label {
            display: block;
            font-size: 0.85rem;
            color: var(--muted);
            margin-bottom: 0.35rem;
        }

        select, button {
            width: 100%;
            border-radius: 10px;
            border: 1px solid rgba(238, 244, 251, 0.2);
            background: var(--panel-soft);
            color: var(--ink);
            padding: 0.65rem 0.75rem;
            font-size: 0.95rem;
        }

        button {
            cursor: pointer;
            transition: transform 120ms ease, filter 120ms ease;
        }

        button:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            transform: none;
            filter: none;
        }

        .start {
            background: var(--accent);
            border-color: transparent;
            color: #101010;
            font-weight: 600;
        }

        .stop {
            background: var(--danger);
            border-color: transparent;
            color: white;
            font-weight: 600;
        }

        #status {
            font-weight: 600;
            margin: 0;
        }

        .meter-row {
            margin-top: 0.45rem;
            display: flex;
            align-items: center;
            gap: 0.65rem;
            flex-wrap: wrap;
        }

        .meter-label {
            color: var(--muted);
            font-size: 0.85rem;
            min-width: 72px;
        }

        .meter-track {
            flex: 1 1 220px;
            height: 12px;
            border-radius: 999px;
            background: rgba(238, 244, 251, 0.14);
            overflow: hidden;
            border: 1px solid rgba(238, 244, 251, 0.2);
        }

        .meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #27d87d, #ffe067, #ff7b29);
            transition: width 80ms linear;
        }

        .meter-value {
            color: #d6e5f5;
            font-family: Consolas, monospace;
            font-size: 0.82rem;
            min-width: 58px;
            text-align: right;
        }

        #log {
            height: 260px;
            overflow: auto;
            background: #06101b;
            border-radius: 10px;
            padding: 0.8rem;
            font-family: Consolas, monospace;
            font-size: 0.86rem;
            line-height: 1.45;
        }

        .line {
            margin: 0.28rem 0;
            color: #d6e5f5;
        }

        .line.system {
            color: #ffd2a7;
        }

        .rooms-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.65rem;
            margin-bottom: 0.75rem;
        }

        .rooms-head h2 {
            margin: 0;
        }

        .rooms-grid {
            display: grid;
            gap: 0.8rem;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        }

        .rooms-column h3 {
            margin: 0 0 0.45rem;
            font-size: 0.95rem;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .rooms-list {
            display: grid;
            gap: 0.55rem;
        }

        .room-card {
            border: 1px solid rgba(238, 244, 251, 0.12);
            border-radius: 12px;
            padding: 0.65rem;
            background: rgba(8, 20, 34, 0.55);
        }

        .room-card.current {
            border-color: rgba(255, 123, 41, 0.55);
            box-shadow: 0 0 0 1px rgba(255, 123, 41, 0.28) inset;
        }

        .room-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .room-id {
            font-family: Consolas, monospace;
            letter-spacing: 0.08em;
            font-weight: 700;
            color: #ffd2a7;
        }

        .room-meta {
            margin: 0.35rem 0 0;
            color: #d6e5f5;
            font-size: 0.84rem;
        }

        .pill {
            border-radius: 999px;
            padding: 0.15rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            border: 1px solid transparent;
        }

        .pill.running {
            color: #0f2a13;
            background: #9be39b;
            border-color: #6fc66f;
        }

        .pill.stopped {
            color: #4a3502;
            background: #ffd87a;
            border-color: #e0b348;
        }

        .room-actions {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.45rem;
            flex-wrap: wrap;
        }

        .room-actions button {
            width: auto;
            padding: 0.4rem 0.6rem;
            font-size: 0.8rem;
        }

        .ghost {
            border-color: rgba(238, 244, 251, 0.25);
            background: transparent;
        }

        .room-empty {
            margin: 0;
            color: var(--muted);
            font-size: 0.86rem;
            border: 1px dashed rgba(238, 244, 251, 0.18);
            border-radius: 10px;
            padding: 0.55rem 0.65rem;
        }
    </style>
</head>
<body>
    <main class="wrap">
        <section class="panel">
            <div class="title-row">
                <img class="title-icon" src="/assets/megaphone.svg" alt="Megaphone icon" />
                <h1>Babbler POC Control</h1>
            </div>
            <p class="muted">Choose input language here. Target language is chosen on the display page.</p>
            <p id="status">Session: checking...</p>
            <p id="usage" class="muted">Free usage: checking...</p>
            <div class="meter-row">
                <span class="meter-label">Mic Level</span>
                <div class="meter-track" role="meter" aria-label="Microphone input level" aria-valuemin="0" aria-valuemax="100">
                    <div id="micLevelFill" class="meter-fill"></div>
                </div>
                <span id="micLevelValue" class="meter-value">0%</span>
            </div>
            <div class="access-box">
                <p class="muted">Room ID</p>
                <div class="access-row">
                    <span id="roomId" class="access-pin">------</span>
                    <button id="newRoomBtn" class="small-btn" type="button">New Room</button>
                </div>
                <p class="muted">Mobile Join URL</p>
                <div class="access-row">
                    <span id="joinUrl" class="access-value">Loading...</span>
                    <button id="copyJoinUrlBtn" class="small-btn" type="button">Copy URL</button>
                </div>
                <p class="muted">PIN</p>
                <div class="access-row">
                    <span id="joinPin" class="access-pin">------</span>
                    <button id="copyPinBtn" class="icon-btn" type="button" title="Copy PIN" aria-label="Copy PIN">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M16 1H6a2 2 0 0 0-2 2v12h2V3h10V1zm3 4H10a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2zm0 16H10V7h9v14z"/>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="grid">
                <div>
                    <label for="sourceLanguage">Source Language</label>
                    <select id="sourceLanguage">
                        <option value="en-US">English (US)</option>
                        <option value="sv-SE">Swedish (Sweden)</option>
                        <option value="es-ES">Spanish (Spain)</option>
                        <option value="fr-FR">French (France)</option>
                        <option value="de-DE">German (Germany)</option>
                        <option value="it-IT">Italian (Italy)</option>
                        <option value="ja-JP">Japanese (Japan)</option>
                    </select>
                </div>
                <div>
                    <label for="micInput">Microphone Input</label>
                    <div class="inline-row">
                        <select id="micInput"></select>
                    </div>
                </div>
                <div>
                    <label>Session Controls</label>
                    <button class="start" id="startBtn" type="button">Start Translation</button>
                </div>
                <div>
                    <label>&nbsp;</label>
                    <button class="stop" id="stopBtn" type="button">Stop Translation</button>
                </div>
                <div>
                    <label>Display Output</label>
                    <button id="openDisplayBtn" type="button">Open Fullscreen Display</button>
                </div>
                <div>
                    <label>&nbsp;</label>
                    <button id="testCaptionBtn" class="ghost" type="button">Test Output</button>
                </div>
            </div>
        </section>

        <section class="panel">
            <div class="rooms-head">
                <h2>Rooms</h2>
                <button id="refreshRoomsBtn" class="small-btn" type="button">Refresh Rooms</button>
            </div>
            <p class="muted">Active rooms are listed live. Stopped rooms stay visible for 2 minutes.</p>
            <div class="rooms-grid">
                <div class="rooms-column">
                    <h3>Active</h3>
                    <div id="activeRooms" class="rooms-list"></div>
                </div>
                <div class="rooms-column">
                    <h3>Recently Stopped</h3>
                    <div id="recentRooms" class="rooms-list"></div>
                </div>
            </div>
        </section>

        <section class="panel">
            <h2>Live Feed</h2>
            <div id="log"></div>
        </section>
    </main>

    <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>
    <script src="/lib/signalr/signalr.min.js"></script>
    <script>
        const statusEl = document.getElementById("status");
        const usageEl = document.getElementById("usage");
        const logEl = document.getElementById("log");
        const roomIdEl = document.getElementById("roomId");
        const newRoomBtn = document.getElementById("newRoomBtn");
        const sourceLanguageEl = document.getElementById("sourceLanguage");
        const joinUrlEl = document.getElementById("joinUrl");
        const joinPinEl = document.getElementById("joinPin");
        const copyJoinUrlBtn = document.getElementById("copyJoinUrlBtn");
        const copyPinBtn = document.getElementById("copyPinBtn");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const openDisplayBtn = document.getElementById("openDisplayBtn");
        const testCaptionBtn = document.getElementById("testCaptionBtn");
        const refreshRoomsBtn = document.getElementById("refreshRoomsBtn");
        const activeRoomsEl = document.getElementById("activeRooms");
        const recentRoomsEl = document.getElementById("recentRooms");
        const micInputEl = document.getElementById("micInput");
        const micLevelFillEl = document.getElementById("micLevelFill");
        const micLevelValueEl = document.getElementById("micLevelValue");
        const recentlyStoppedWindowMs = 2 * 60 * 1000;
        let currentRoomId = "";
        let currentJoinPin = "";
        let currentJoinUrl = "";
        let statusPollHandle = null;
        let roomPollHandle = null;
        let diagPollHandle = null;
        let roomDiagPollHandle = null;
        let connection = null;
        let freeLimitReached = false;
        let browserRecognizer = null;
        let browserRecognizerRoomId = "";
        let micWatchdogHandle = null;
        let lastMicActivityAt = 0;
        let lastMicWarningAt = 0;
        let roomRecoveryInProgress = false;
        let lastPublishErrorAt = 0;
        let micMeterAudioContext = null;
        let micMeterStream = null;
        let micMeterAnalyser = null;
        let micMeterSource = null;
        let micMeterFrameHandle = null;
        let selectedMicDeviceId = "";
        let currentRecognitionDeviceId = "";
        let micSwitchInProgress = false;
        let recognizerRestartInProgress = false;
        let lastRecognizerRestartAt = 0;
        let micNoSpeechRecoveryInProgress = false;
        let lastMicAutoFallbackAt = 0;
        let lastRoomDiagStateSignature = "";
        let lastRoomDiagWarningAt = 0;
        const signalRClient = window.signalR;
        const speechSdk = window.SpeechSDK;
        const supportedTargetLanguages = ["en", "sv", "es", "fr", "de", "it", "ja"];

        if (!signalRClient) {
            statusEl.textContent = "Session: client library missing";
            addLine("[error] SignalR client failed to load from /lib/signalr/signalr.min.js.", true);
            throw new Error("SignalR client failed to load.");
        }

        if (!speechSdk) {
            statusEl.textContent = "Session: speech library missing";
            addLine("[error] Azure Speech JS SDK failed to load.", true);
            throw new Error("Speech SDK failed to load.");
        }

        startBtn.addEventListener("click", async () => {
            try {
                await startRoom(currentRoomId);
            } catch (err) {
                addLine(`[error] ${err.message || "Unable to start session."}`, true);
            }
        });

        stopBtn.addEventListener("click", async () => {
            try {
                await stopRoom(currentRoomId, "manual");
            } catch (err) {
                addLine(`[error] ${err.message || "Unable to stop session."}`, true);
            }
        });

        openDisplayBtn.addEventListener("click", () => {
            try {
                openDisplay();
            } catch (err) {
                addLine(`[error] ${err.message || "Unable to open display."}`, true);
            }
        });

        testCaptionBtn.addEventListener("click", async () => {
            try {
                await sendTestCaption();
            } catch (err) {
                addLine(`[error] ${err.message || "Unable to send test output."}`, true);
            }
        });

        refreshRoomsBtn.addEventListener("click", async () => {
            try {
                await refreshRooms();
            } catch (err) {
                addLine(`[error] ${err.message || "Unable to load rooms."}`, true);
            }
        });

        micInputEl.addEventListener("change", async () => {
            const requestedMicDeviceId = getSelectedMicDeviceId();

            if (micSwitchInProgress) {
                return;
            }

            micSwitchInProgress = true;
            try {
                await ensureMicrophonePermission();
                await refreshMicrophoneDevices(true);

                if (requestedMicDeviceId &&
                    Array.from(micInputEl.options).some(option => option.value === requestedMicDeviceId))
                {
                    micInputEl.value = requestedMicDeviceId;
                }

                selectedMicDeviceId = getSelectedMicDeviceId();
                const selectedLabel = getSelectedMicLabel();
                addLine(`[system] Mic input selected: ${selectedLabel}`, true);

                if (browserRecognizer && browserRecognizerRoomId) {
                    addLine("[system] Applying microphone change...", true);
                    await startBrowserRecognition(browserRecognizerRoomId, sourceLanguageEl.value);
                    addLine(`[system] Microphone switched to "${selectedLabel}".`, true);
                    return;
                }

                stopMicLevelMeter();
                await startMicLevelMeter(selectedMicDeviceId);
            } catch (err) {
                addLine(`[error] Unable to switch microphone now: ${err?.message || err}`, true);
            } finally {
                micSwitchInProgress = false;
            }
        });

        if (navigator.mediaDevices && typeof navigator.mediaDevices.addEventListener === "function") {
            navigator.mediaDevices.addEventListener("devicechange", () => {
                refreshMicrophoneDevices(true).catch(() => {
                    // Ignore transient media device change errors.
                });
            });
        }

        newRoomBtn.addEventListener("click", async () => {
            newRoomBtn.disabled = true;
            try {
                const room = await createRoom();
                addLine(`[system] New room created: ${room.roomId}`, true);
                await switchRoom(room.roomId);
            } catch (err) {
                addLine(`[error] ${err.message || "Unable to create room."}`, true);
            } finally {
                newRoomBtn.disabled = false;
            }
        });

        copyJoinUrlBtn.addEventListener("click", async () => {
            if (!currentJoinUrl) {
                return;
            }

            try {
                await navigator.clipboard.writeText(currentJoinUrl);
                addLine("[system] Join URL copied to clipboard.", true);
            } catch {
                addLine("[error] Clipboard copy failed.", true);
            }
        });

        copyPinBtn.addEventListener("click", async () => {
            if (!currentJoinPin) {
                return;
            }

            try {
                await navigator.clipboard.writeText(currentJoinPin);
                addLine("[system] PIN copied to clipboard.", true);
            } catch {
                addLine("[error] Clipboard copy failed.", true);
            }
        });

        function addLine(text, isSystem = false) {
            const line = document.createElement("p");
            line.className = isSystem ? "line system" : "line";
            line.textContent = text;
            logEl.prepend(line);
        }

        function updateStatus(state) {
            freeLimitReached = Boolean(state.freeLimitReached);

            const running = state.isRunning ? "running" : "stopped";
            const languages = state.sourceLanguage && state.targetLanguage
                ? ` (${state.sourceLanguage} -> ${state.targetLanguage})`
                : "";
            const roomLabel = currentRoomId ? ` (${currentRoomId})` : "";
            statusEl.textContent = `Session${roomLabel}: ${running}${languages}`;

            const used = formatMinutes(state.freeMinutesUsed);
            const limit = formatMinutes(state.freeMinutesLimit);
            const remaining = formatMinutes(state.freeMinutesRemaining);
            const blocked = state.freeLimitReached ? " (limit reached)" : "";
            usageEl.textContent = `Free usage: ${used} / ${limit} min used, ${remaining} min left${blocked}`;

            startBtn.disabled = freeLimitReached;
            stopBtn.disabled = !state.isRunning;
        }

        function formatMinutes(value) {
            const numeric = Number(value);
            if (Number.isNaN(numeric)) {
                return "0.00";
            }

            return numeric.toFixed(2);
        }

        function roomApiBase(roomId = currentRoomId) {
            if (!roomId) {
                throw new Error("No room selected.");
            }

            return `/api/rooms/${encodeURIComponent(roomId)}`;
        }

        function getRoomIdFromQuery() {
            const params = new URLSearchParams(window.location.search);
            return (params.get("roomId") || "").trim().toUpperCase();
        }

        function setRoomIdInQuery(roomId) {
            const url = new URL(window.location.href);
            url.searchParams.set("roomId", roomId);
            window.history.replaceState({}, "", url);
        }

        async function refreshStatus() {
            const response = await fetchJson(`${roomApiBase()}/session/status`);
            if (!response.ok) {
                throw new Error(response.errorMessage);
            }

            updateStatus(response.data);

            if (!response.data?.isRunning && browserRecognizerRoomId === currentRoomId) {
                await stopBrowserRecognition();
            }
        }

        async function refreshAccessInfo() {
            const response = await fetchJson(`${roomApiBase()}/access-info`);
            if (!response.ok) {
                if (isRoomNotFoundError(response.errorMessage)) {
                    await recoverFromMissingRoom("Room access info not found.");
                    return;
                }

                throw new Error(response.errorMessage);
            }

            currentRoomId = response.data?.roomId || currentRoomId;
            currentJoinPin = response.data?.pin || "";
            currentJoinUrl = response.data?.joinUrl || "";

            roomIdEl.textContent = currentRoomId || "------";
            joinPinEl.textContent = currentJoinPin || "------";
            joinUrlEl.textContent = currentJoinUrl || "Unavailable";
        }

        async function createRoom() {
            const response = await fetchJson("/api/rooms", {
                method: "POST"
            });
            if (!response.ok) {
                throw new Error(response.errorMessage);
            }

            return response.data;
        }

        async function refreshRooms() {
            const response = await fetchJson("/api/rooms");
            if (!response.ok) {
                throw new Error(response.errorMessage);
            }

            const rooms = Array.isArray(response.data) ? response.data : [];
            const activeRooms = rooms.filter(room => room.isRunning);
            const recentlyStoppedRooms = rooms.filter(room =>
                !room.isRunning && isRecentlyStopped(room));

            renderRoomList(activeRoomsEl, activeRooms, true, "No active rooms.");
            renderRoomList(recentRoomsEl, recentlyStoppedRooms, false, "No recently stopped rooms.");
        }

        function isRecentlyStopped(room) {
            if (!room || !room.lastStoppedAtUtc) {
                return false;
            }

            const stoppedAt = Date.parse(room.lastStoppedAtUtc);
            if (Number.isNaN(stoppedAt)) {
                return false;
            }

            return Date.now() - stoppedAt <= recentlyStoppedWindowMs;
        }

        function renderRoomList(container, rooms, isActiveList, emptyMessage) {
            container.replaceChildren();

            if (!rooms.length) {
                const empty = document.createElement("p");
                empty.className = "room-empty";
                empty.textContent = emptyMessage;
                container.appendChild(empty);
                return;
            }

            for (const room of rooms) {
                container.appendChild(buildRoomCard(room, isActiveList));
            }
        }

        function buildRoomCard(room, isActiveList) {
            const card = document.createElement("article");
            card.className = "room-card";
            if (room.roomId === currentRoomId) {
                card.classList.add("current");
            }

            const top = document.createElement("div");
            top.className = "room-top";

            const roomId = document.createElement("span");
            roomId.className = "room-id";
            roomId.textContent = room.roomId;

            const pill = document.createElement("span");
            pill.className = `pill ${room.isRunning ? "running" : "stopped"}`;
            pill.textContent = room.isRunning ? "Running" : "Stopped";

            top.appendChild(roomId);
            top.appendChild(pill);
            card.appendChild(top);

            const meta = document.createElement("p");
            meta.className = "room-meta";
            meta.textContent = describeRoomLanguage(room);
            card.appendChild(meta);

            const actions = document.createElement("div");
            actions.className = "room-actions";

            actions.appendChild(makeActionButton("Select", "ghost", async () => {
                await switchRoom(room.roomId);
            }));

            actions.appendChild(makeActionButton("Open", "ghost", async () => {
                openDisplay(room.roomId);
            }));

            if (isActiveList) {
                actions.appendChild(makeActionButton("Stop", "stop", async () => {
                    await stopRoom(room.roomId, "manual");
                }));
            } else {
                const startButton = makeActionButton("Start", "start", async () => {
                    await startRoom(room.roomId);
                });
                startButton.disabled = freeLimitReached;
                actions.appendChild(startButton);
            }

            card.appendChild(actions);
            return card;
        }

        function describeRoomLanguage(room) {
            if (room.sourceLanguage && room.targetLanguage) {
                return `${room.sourceLanguage} -> ${room.targetLanguage}`;
            }

            if (room.targetLanguage) {
                return `target ${room.targetLanguage}`;
            }

            return "no language selected yet";
        }

        function makeActionButton(label, className, action) {
            const button = document.createElement("button");
            button.type = "button";
            button.className = className;
            button.textContent = label;
            button.addEventListener("click", async () => {
                if (button.disabled) {
                    return;
                }

                button.disabled = true;
                try {
                    await action();
                } catch (err) {
                    addLine(`[error] ${err.message || "Action failed."}`, true);
                } finally {
                    button.disabled = false;
                }
            });

            return button;
        }

        async function getSpeechToken() {
            const response = await fetchJson("/api/speech/token");
            if (!response.ok) {
                throw new Error(response.errorMessage);
            }

            const token = response.data?.token;
            const region = response.data?.region;
            if (!token || !region) {
                throw new Error("Speech token response was invalid.");
            }

            return { token, region };
        }

        function getSelectedMicDeviceId() {
            const value = (micInputEl.value || "").trim();
            return value || "";
        }

        function getSelectedMicLabel() {
            const option = micInputEl.options[micInputEl.selectedIndex];
            return option?.textContent?.trim() || "Default microphone";
        }

        async function refreshMicrophoneDevices(preserveSelection) {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                micInputEl.innerHTML = "";
                const option = document.createElement("option");
                option.value = "";
                option.textContent = "Microphone selection unsupported";
                micInputEl.appendChild(option);
                micInputEl.disabled = true;
                selectedMicDeviceId = "";
                return;
            }

            const previousValue = preserveSelection ? getSelectedMicDeviceId() : "";
            const devices = await navigator.mediaDevices.enumerateDevices();
            const microphones = devices.filter(device => device.kind === "audioinput");

            micInputEl.innerHTML = "";

            const defaultOption = document.createElement("option");
            defaultOption.value = "";
            defaultOption.textContent = "System default microphone";
            micInputEl.appendChild(defaultOption);

            microphones.forEach((device, index) => {
                const option = document.createElement("option");
                option.value = device.deviceId || "";
                option.textContent = device.label || `Microphone ${index + 1}`;
                micInputEl.appendChild(option);
            });

            const canRestore = previousValue &&
                Array.from(micInputEl.options).some(option => option.value === previousValue);
            micInputEl.value = canRestore ? previousValue : "";
            selectedMicDeviceId = getSelectedMicDeviceId();
            micInputEl.disabled = false;
        }

        async function ensureMicrophonePermission() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                return;
            }

            let stream = null;
            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            } finally {
                if (stream) {
                    for (const track of stream.getTracks()) {
                        track.stop();
                    }
                }
            }
        }

        function createSpeechAudioConfig(deviceId) {
            if (deviceId && typeof speechSdk.AudioConfig.fromMicrophoneInput === "function") {
                try {
                    return speechSdk.AudioConfig.fromMicrophoneInput(deviceId);
                } catch (err) {
                    addLine(`[error] Selected mic could not be opened. Falling back to default. (${err?.message || err})`, true);
                }
            }

            return speechSdk.AudioConfig.fromDefaultMicrophoneInput();
        }

        function buildTranslationRecognizer(speechConfig, audioConfig, roomId, sourceLanguage) {
            const recognizer = new speechSdk.TranslationRecognizer(
                speechConfig,
                audioConfig);

            recognizer.recognizing = (_, event) => {
                if (event?.result?.text) {
                    lastMicActivityAt = Date.now();
                }
                publishRecognitionResult(sourceLanguage, false, event?.result);
            };

            recognizer.recognized = (_, event) => {
                if (event?.result?.text) {
                    lastMicActivityAt = Date.now();
                    addLine(`[mic-final] ${event.result.text}`);
                }
                publishRecognitionResult(sourceLanguage, true, event?.result);
            };

            recognizer.sessionStopped = () => {
                addLine("[system] Speech session stopped.", true);
            };

            recognizer.canceled = (_, event) => {
                const details = event?.errorDetails ? ` (${event.errorDetails})` : "";
                addLine(`[error] Speech canceled: ${event?.reason || "unknown"}${details}`, true);

                if (!browserRecognizer || browserRecognizerRoomId !== roomId) {
                    return;
                }

                const now = Date.now();
                if (recognizerRestartInProgress || now - lastRecognizerRestartAt < 4000) {
                    return;
                }

                lastRecognizerRestartAt = now;
                recognizerRestartInProgress = true;
                addLine("[system] Restarting microphone recognition...", true);
                startBrowserRecognition(roomId, sourceLanguage).then(() => {
                    addLine("[system] Microphone recognition restarted.", true);
                }).catch(err => {
                    addLine(`[error] Auto-restart failed: ${err?.message || err}`, true);
                }).finally(() => {
                    recognizerRestartInProgress = false;
                });
            };

            return recognizer;
        }

        function toPromise(startOrStop) {
            return new Promise((resolve, reject) => {
                startOrStop(resolve, reject);
            });
        }

        async function startBrowserRecognition(roomId, sourceLanguage) {
            if (!connection) {
                throw new Error("SignalR connection is not ready.");
            }

            if (browserRecognizer) {
                await stopBrowserRecognition();
            }

            const speechToken = await getSpeechToken();
            const speechConfig = speechSdk.SpeechTranslationConfig
                .fromAuthorizationToken(speechToken.token, speechToken.region);
            speechConfig.speechRecognitionLanguage = sourceLanguage;
            const sourceNeutralLanguage = (sourceLanguage || "").split("-")[0].toLowerCase();

            for (const targetLanguage of supportedTargetLanguages) {
                if (targetLanguage.toLowerCase() === sourceNeutralLanguage) {
                    continue;
                }
                speechConfig.addTargetLanguage(targetLanguage);
            }

            const selectedDeviceId = getSelectedMicDeviceId();
            let recognizer = buildTranslationRecognizer(
                speechConfig,
                createSpeechAudioConfig(selectedDeviceId),
                roomId,
                sourceLanguage);
            let activeDeviceId = selectedDeviceId;
            let activeDeviceLabel = getSelectedMicLabel();
            try {
                await toPromise((ok, fail) => recognizer.startContinuousRecognitionAsync(ok, fail));
            } catch (err) {
                recognizer.close();

                if (!selectedDeviceId) {
                    throw new Error(`Microphone start failed: ${err?.message || err || "unknown error"}`);
                }

                addLine(
                    `[error] Selected microphone failed to start. Retrying system default. (${err?.message || err || "unknown error"})`,
                    true);

                activeDeviceId = "";
                activeDeviceLabel = "System default microphone";
                selectedMicDeviceId = "";
                micInputEl.value = "";

                recognizer = buildTranslationRecognizer(
                    speechConfig,
                    speechSdk.AudioConfig.fromDefaultMicrophoneInput(),
                    roomId,
                    sourceLanguage);

                try {
                    await toPromise((ok, fail) => recognizer.startContinuousRecognitionAsync(ok, fail));
                } catch (retryErr) {
                    recognizer.close();
                    throw new Error(
                        `Microphone start failed after fallback: ${retryErr?.message || retryErr || "unknown error"}`);
                }
            }

            browserRecognizer = recognizer;
            browserRecognizerRoomId = roomId;
            currentRecognitionDeviceId = activeDeviceId;
            lastMicActivityAt = Date.now();
            lastMicWarningAt = 0;
            startMicWatchdog();
            await startMicLevelMeter(activeDeviceId);
            await refreshMicrophoneDevices(true);
            if (activeDeviceId &&
                Array.from(micInputEl.options).some(option => option.value === activeDeviceId))
            {
                micInputEl.value = activeDeviceId;
            }
            addLine(`[system] Microphone active (${sourceLanguage} -> room target) using "${activeDeviceLabel}".`, true);
        }

        async function stopBrowserRecognition() {
            if (!browserRecognizer) {
                browserRecognizerRoomId = "";
                currentRecognitionDeviceId = "";
                return;
            }

            const recognizer = browserRecognizer;
            browserRecognizer = null;
            browserRecognizerRoomId = "";
            currentRecognitionDeviceId = "";
            stopMicWatchdog();
            stopMicLevelMeter();

            try {
                await toPromise((ok, fail) => recognizer.stopContinuousRecognitionAsync(ok, fail));
            } catch {
                // Ignore recognizer stop errors.
            }

            recognizer.close();
        }

        function startMicWatchdog() {
            stopMicWatchdog();
            micWatchdogHandle = setInterval(() => {
                if (!browserRecognizer) {
                    return;
                }

                const now = Date.now();
                if (now - lastMicActivityAt < 15000) {
                    return;
                }

                if (now - lastMicWarningAt < 15000) {
                    return;
                }

                lastMicWarningAt = now;
                addLine("[error] No speech detected from microphone yet. Check browser mic input device and site permission.", true);

                if (now - lastMicActivityAt < 25000) {
                    return;
                }

                if (!currentRecognitionDeviceId || !browserRecognizerRoomId) {
                    return;
                }

                if (micNoSpeechRecoveryInProgress || recognizerRestartInProgress) {
                    return;
                }

                if (now - lastMicAutoFallbackAt < 30000) {
                    return;
                }

                micNoSpeechRecoveryInProgress = true;
                lastMicAutoFallbackAt = now;
                addLine(
                    "[system] No speech recognized from selected microphone. Switching to system default mic.",
                    true);

                selectedMicDeviceId = "";
                currentRecognitionDeviceId = "";
                micInputEl.value = "";

                startBrowserRecognition(browserRecognizerRoomId, sourceLanguageEl.value)
                    .then(() => {
                        addLine("[system] Fallback to system default mic applied.", true);
                    })
                    .catch(err => {
                        addLine(`[error] Automatic fallback to default mic failed: ${err?.message || err}`, true);
                    })
                    .finally(() => {
                        micNoSpeechRecoveryInProgress = false;
                    });
            }, 5000);
        }

        function stopMicWatchdog() {
            if (micWatchdogHandle !== null) {
                clearInterval(micWatchdogHandle);
                micWatchdogHandle = null;
            }
        }

        async function startMicLevelMeter(deviceId) {
            if (micMeterAnalyser) {
                return;
            }

            try {
                const audioConstraint = deviceId
                    ? { deviceId: { exact: deviceId }, echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                    : { echoCancellation: true, noiseSuppression: true, autoGainControl: true };

                let stream = null;
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraint, video: false });
                } catch {
                    stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                }

                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 1024;
                analyser.smoothingTimeConstant = 0.82;

                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);

                micMeterStream = stream;
                micMeterAudioContext = audioContext;
                micMeterAnalyser = analyser;
                micMeterSource = source;

                runMicMeterFrame();
            } catch (err) {
                addLine(`[error] Mic meter unavailable: ${err?.message || err}`, true);
            }
        }

        function stopMicLevelMeter() {
            if (micMeterFrameHandle !== null) {
                cancelAnimationFrame(micMeterFrameHandle);
                micMeterFrameHandle = null;
            }

            if (micMeterSource) {
                try {
                    micMeterSource.disconnect();
                } catch {
                    // Ignore disconnect errors.
                }
                micMeterSource = null;
            }

            if (micMeterStream) {
                for (const track of micMeterStream.getTracks()) {
                    track.stop();
                }
                micMeterStream = null;
            }

            if (micMeterAudioContext) {
                micMeterAudioContext.close().catch(() => {
                    // Ignore close errors.
                });
                micMeterAudioContext = null;
            }

            micMeterAnalyser = null;
            setMicLevel(0);
        }

        function runMicMeterFrame() {
            if (!micMeterAnalyser) {
                setMicLevel(0);
                return;
            }

            const bufferLength = micMeterAnalyser.fftSize;
            const dataArray = new Uint8Array(bufferLength);
            micMeterAnalyser.getByteTimeDomainData(dataArray);

            let sumSquares = 0;
            for (let i = 0; i < bufferLength; i++) {
                const centered = (dataArray[i] - 128) / 128;
                sumSquares += centered * centered;
            }

            const rms = Math.sqrt(sumSquares / bufferLength);
            const percent = Math.max(0, Math.min(100, Math.round(rms * 240)));
            setMicLevel(percent);

            micMeterFrameHandle = requestAnimationFrame(runMicMeterFrame);
        }

        function setMicLevel(percent) {
            micLevelFillEl.style.width = `${percent}%`;
            micLevelValueEl.textContent = `${percent}%`;
        }

        function publishRecognitionResult(sourceLanguage, isFinal, result) {
            if (!connection || !result) {
                return;
            }

            const sourceText = (result.text || "").trim();
            const translations = {};
            for (const targetLanguage of supportedTargetLanguages) {
                const translated = result.translations?.get?.(targetLanguage);
                if (translated && translated.trim()) {
                    translations[targetLanguage] = translated;
                }
            }

            if (!sourceText && Object.keys(translations).length === 0) {
                return;
            }

            connection.invoke("PublishClientTranslation", {
                sourceText,
                sourceLanguage,
                isFinal,
                translations
            }).catch(err => {
                // Keep translating even on transient publish failures.
                if (Date.now() - lastPublishErrorAt > 5000) {
                    lastPublishErrorAt = Date.now();
                    addLine(`[error] Live publish failed: ${err?.message || err}`, true);
                }
            });
        }

        async function startRoom(roomId) {
            if (roomId !== currentRoomId) {
                await switchRoom(roomId);
            }

            const payload = {
                sourceLanguage: sourceLanguageEl.value
            };

            const response = await fetchJson(`${roomApiBase(roomId)}/session/start`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                throw new Error(response.errorMessage);
            }

            if (roomId === currentRoomId) {
                updateStatus(response.data);
            } else {
                await refreshStatusSafe();
            }

            try {
                await startBrowserRecognition(roomId, sourceLanguageEl.value);
            } catch (err) {
                await stopRoom(roomId, "recognizer-start-failed");
                await refreshStatusSafe();
                await refreshRoomsSafe();
                throw err;
            }

            await refreshRoomsSafe();
            addLine(`[system] Room ${roomId} started.`, true);
        }

        async function stopRoom(roomId, reason = "manual") {
            if (browserRecognizerRoomId === roomId) {
                await stopBrowserRecognition();
            } else {
                stopMicLevelMeter();
            }

            const reasonParam = encodeURIComponent((reason || "manual").trim());
            const response = await fetchJson(`${roomApiBase(roomId)}/session/stop?reason=${reasonParam}`, {
                method: "POST"
            });
            if (!response.ok) {
                throw new Error(response.errorMessage);
            }

            if (roomId === currentRoomId) {
                updateStatus(response.data);
            } else {
                await refreshStatusSafe();
            }

            await refreshRoomsSafe();
            addLine(`[system] Room ${roomId} stopped (${reason}).`, true);
        }

        async function connectToRoom(roomId) {
            if (connection) {
                try {
                    await connection.stop();
                } catch {
                    // Ignore connection stop errors.
                }
            }

            const nextConnection = new signalRClient.HubConnectionBuilder()
                .withUrl(`/hubs/translation?roomId=${encodeURIComponent(roomId)}`, {
                    transport: signalRClient.HttpTransportType.LongPolling
                })
                .withAutomaticReconnect()
                .build();

            nextConnection.on("translationUpdate", data => {
                if (data.systemMessage) {
                    addLine(`[system] ${data.systemMessage}`, true);
                    refreshStatusSafe();
                    refreshRoomsSafe();
                    return;
                }

                const liveText = data.translatedText || data.sourceText;
                if (!liveText) {
                    return;
                }

                const marker = data.isFinal ? "final" : "partial";
                addLine(`[${marker}] ${liveText}`);
            });

            nextConnection.onreconnecting(() => {
                addLine("[system] Reconnecting live feed...", true);
            });

            nextConnection.onreconnected(() => {
                addLine("[system] Live feed reconnected.", true);
            });

            nextConnection.onclose(err => {
                const message = err?.message || "Connection closed.";
                addLine(`[error] Live feed disconnected: ${message}`, true);
            });

            await nextConnection.start();
            connection = nextConnection;
        }

        async function switchRoom(roomId) {
            if (browserRecognizerRoomId && browserRecognizerRoomId !== roomId) {
                await stopRoom(browserRecognizerRoomId, "switch-room");
            }

            currentRoomId = roomId;
            lastRoomDiagStateSignature = "";
            setRoomIdInQuery(roomId);
            await connectToRoom(roomId);
            await refreshAccessInfo();
            await refreshStatus();
            await refreshRoomsSafe();
            await refreshRoomDiagnosticsSafe();
        }

        async function ensureRoom() {
            const requestedRoomId = getRoomIdFromQuery();
            if (requestedRoomId) {
                try {
                    await switchRoom(requestedRoomId);
                    return;
                } catch {
                    addLine(`[system] Room ${requestedRoomId} not found. Creating a new room.`, true);
                }
            }

            const room = await createRoom();
            await switchRoom((room?.roomId || "").toUpperCase());
        }

        function openDisplay(roomId = currentRoomId) {
            if (!roomId) {
                throw new Error("No room selected.");
            }

            window.open(`/join.html?roomId=${encodeURIComponent(roomId)}`, "_blank");
        }

        function startStatusPolling() {
            if (statusPollHandle !== null) {
                clearInterval(statusPollHandle);
            }

            statusPollHandle = setInterval(async () => {
                await refreshStatusSafe();
            }, 5000);
        }

        function startRoomPolling() {
            if (roomPollHandle !== null) {
                clearInterval(roomPollHandle);
            }

            roomPollHandle = setInterval(async () => {
                await refreshRoomsSafe();
            }, 4000);
        }

        async function refreshStatusSafe() {
            try {
                await refreshStatus();
            } catch (err) {
                if (isRoomNotFoundError(err?.message)) {
                    await recoverFromMissingRoom("Current room no longer exists.");
                    return;
                }

                // Ignore transient poll errors and keep trying.
            }
        }

        async function refreshRoomsSafe() {
            try {
                await refreshRooms();
            } catch {
                // Ignore transient poll errors and keep trying.
            }
        }

        async function refreshDiagnostics() {
            const response = await fetchJson("/api/diag");
            if (!response.ok || !response.data) {
                throw new Error(response.errorMessage || "Diagnostics unavailable.");
            }

            const diag = response.data;
            const roomSummary = `rooms=${diag.roomsCount ?? "?"}, running=${diag.runningRoomsCount ?? "?"}`;
            const version = diag.version || "n/a";
            addLine(`[system] diag: env=${diag.environment || "?"}, version=${version}, ${roomSummary}`, true);
        }

        async function refreshDiagnosticsSafe() {
            try {
                await refreshDiagnostics();
            } catch {
                // Ignore diagnostic poll errors.
            }
        }

        async function refreshRoomDiagnostics() {
            const response = await fetchJson(`${roomApiBase()}/diag`);
            if (!response.ok || !response.data) {
                throw new Error(response.errorMessage || "Room diagnostics unavailable.");
            }

            const diag = response.data;
            const publishAgeMs = diag.lastClientPublishAtUtc
                ? Date.now() - Date.parse(diag.lastClientPublishAtUtc)
                : null;

            const signature = [
                diag.isRunning ? "running" : "stopped",
                diag.lastStopReason || "",
                diag.lastClientPublishAtUtc || "",
                diag.activeHubConnections ?? 0
            ].join("|");

            if (signature !== lastRoomDiagStateSignature) {
                lastRoomDiagStateSignature = signature;
                if (!diag.isRunning && diag.lastStopReason) {
                    addLine(`[system] Room stop reason: ${diag.lastStopReason}`, true);
                }
            }

            if (diag.isRunning && (publishAgeMs === null || publishAgeMs > 15000)) {
                const now = Date.now();
                if (now - lastRoomDiagWarningAt > 15000) {
                    lastRoomDiagWarningAt = now;
                    addLine(
                        `[error] No captions published recently while room is running (clients=${diag.activeHubConnections ?? 0}).`,
                        true);
                }
            }
        }

        async function refreshRoomDiagnosticsSafe() {
            try {
                await refreshRoomDiagnostics();
            } catch {
                // Ignore transient room diagnostic errors.
            }
        }

        function startRoomDiagnosticsPolling() {
            if (roomDiagPollHandle !== null) {
                clearInterval(roomDiagPollHandle);
            }

            roomDiagPollHandle = setInterval(async () => {
                await refreshRoomDiagnosticsSafe();
            }, 7000);
        }

        async function sendTestCaption() {
            const testText = `Caption test ${new Date().toLocaleTimeString()}`;
            const response = await fetchJson(`${roomApiBase()}/debug/test-caption`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ text: testText })
            });

            if (!response.ok) {
                throw new Error(response.errorMessage);
            }

            addLine(`[system] Test caption sent: ${testText}`, true);
        }

        function isRoomNotFoundError(message) {
            return (message || "").toLowerCase().includes("not found");
        }

        async function recoverFromMissingRoom(reason) {
            if (roomRecoveryInProgress) {
                return;
            }

            roomRecoveryInProgress = true;
            try {
                addLine(`[system] ${reason} Creating a new room.`, true);
                const room = await createRoom();
                await switchRoom((room?.roomId || "").toUpperCase());
            } catch (err) {
                addLine(`[error] ${err.message || "Unable to recover from missing room."}`, true);
            } finally {
                roomRecoveryInProgress = false;
            }
        }

        async function fetchJson(url, options) {
            const response = await fetch(url, options || {});
            const raw = await response.text();

            let data = null;
            if (raw) {
                try {
                    data = JSON.parse(raw);
                } catch {
                    data = null;
                }
            }

            let errorMessage = `Request failed (${response.status}).`;
            if (data && data.error) {
                errorMessage = data.error;
            } else if (raw) {
                errorMessage = raw;
            }

            return {
                ok: response.ok,
                data,
                errorMessage
            };
        }

        async function init() {
            try {
                await refreshMicrophoneDevices(true);
            } catch (err) {
                addLine(`[error] Mic device list unavailable: ${err?.message || err}`, true);
            }
            await ensureRoom();
            await refreshRoomsSafe();
            await refreshDiagnosticsSafe();
            await refreshRoomDiagnosticsSafe();
            startStatusPolling();
            startRoomPolling();
            startRoomDiagnosticsPolling();

            if (diagPollHandle !== null) {
                clearInterval(diagPollHandle);
            }
            diagPollHandle = setInterval(async () => {
                await refreshDiagnosticsSafe();
            }, 30000);
        }

        init().catch(err => addLine(`[error] ${err.message}`, true));
    </script>
</body>
</html>
